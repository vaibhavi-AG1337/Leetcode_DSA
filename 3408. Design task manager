#include <iostream>
#include <vector>
#include <map>
#include <set>

using namespace std;

class TaskManager {
private:
    struct Task {
        int userId;
        int taskId;
        int priority;

        bool operator<(const Task& other) const {
            if (priority != other.priority) {
                return priority > other.priority; // Highest priority first
            }
            return taskId > other.taskId; // Highest taskId first for tie-breaking
        }
    };

    map<int, Task> taskMap; // taskId -> Task object
    set<Task> taskSet; // Stores tasks sorted by priority and taskId

public:
    TaskManager(vector<vector<int>>& tasks) {
        for (const auto& taskInfo : tasks) {
            int userId = taskInfo[0];
            int taskId = taskInfo[1];
            int priority = taskInfo[2];
            Task task = {userId, taskId, priority};
            taskMap[taskId] = task;
            taskSet.insert(task);
        }
    }

    void add(int userId, int taskId, int priority) {
        Task task = {userId, taskId, priority};
        taskMap[taskId] = task;
        taskSet.insert(task);
    }

    void edit(int taskId, int newPriority) {
        Task oldTask = taskMap[taskId];
        taskSet.erase(oldTask);

        oldTask.priority = newPriority;
        taskMap[taskId] = oldTask;
        taskSet.insert(oldTask);
    }

    void rmv(int taskId) {
        Task task = taskMap[taskId];
        taskMap.erase(taskId);
        taskSet.erase(task);
    }

    int execTop() {
        if (taskSet.empty()) {
            return -1;
        }
        
        Task topTask = *taskSet.begin();
        int userId = topTask.userId;
        int taskId = topTask.taskId;

        taskSet.erase(taskSet.begin());
        taskMap.erase(taskId);
        
        return userId;
    }
};
